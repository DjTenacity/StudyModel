定义
策略模式定义了一系列的算法，并将每一个算法封装起来，
而且使他们之间可以相互替换，策略模式让算法独立于使它的客户独立而变化

角色
环境(Context)角色  持有一个Strategy的引用
抽象策略(Strategy)角色  这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
具体策略(ConcreteStrategy)角色  包装了相关的算法或行为。

//*****************************************
    策略模式,是在客户端进行实例化,
            注重在算法的包装,算法是独立开来的,并且切记:是可替换的,让客户端独立而变化

    状态模式,状态是在上下文中new的,并不是在调用层new的
            是调用上下文的方法进行状态的切换,

     大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。
     从设计师的角度，他们希望App能够有更多的动画，图片等时尚元素来实现流畅的用户体验。
     但是Android系统很有可能无法及时完成那些复杂的界面渲染操作。
     Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，
     这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。

//*****************************************

需求
假设现在要一个上商店个搞活动。 对所有的高级会员打20%的促销折扣；对中级会员打10%的促销折扣；对初级会员没有折扣。

得知算法
　   算法一：对初级会员没有折扣。

　　算法二：对中级会员提供10%的促销折扣。

算法三：对高级会员提供20%的促销折扣。

重点
　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。


特点
运行时策略的唯一性
运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。
平等性
　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。

优缺点
优点
策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法让子类实现
缺点
客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。
换言之，策略模式只适用于客户端知道算法或行为的情况。
由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。